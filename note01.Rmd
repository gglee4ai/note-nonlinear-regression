---
title: "R Notebook"
output: html_notebook
---


# setup

```{r}
# devtools::install_github("cran/drc")
# devtools::install_github("cran/alr3")
# devtools::install_github("cran/NRAIA")
# devtools::install_github("cran/nlrwr")
library(nlrwr)
```


# 1 Introduction

## 1.1 A stock-recruitment model

```{r}
plot(num.fish ~ spawn.biomass, 
     data = M.merluccius, 
     xlab = "Spawning biomass (1000 tonnes)",
     ylab = "Recruitment (million fish)")
```


## 1.2 Competition between plant biotypes

```{r}
plot(biomass ~ x, 
     data = RScompetition, 
     log = "", 
     xlab = Density ~ (plants/m^2), 
     ylab = Biomass ~ of ~ sensitive ~ biotype ~ (g/plant), 
     pch = as.numeric(as.factor(RScompetition$z)))
```


## 1.3 Grouped dose-response data

```{r}
xyplot(DryMatter ~ Dose | Herbicide,
       data = S.alba, 
       scales = list(x = list(log = TRUE)),
       ylab = "Dry matter (g/pot)",
       xlab = "Dose (g/ha)")
```


# 2 Getting Started

## 2.2 Getting started with nls()

2.2.1 Introducing the data example

```{r}
L.minor
```


```{r}
plot(rate ~ conc, data = L.minor,
     ylab = "Uptake rate (weight/h)", 
     xlab = Substrate ~ concentration ~ (mmol ~ m^-3))
```


2.2.2 Model fitting

```{r}
L.minor.m1 <- nls(rate ~ Vm * conc/(K + conc), 
                  data = L.minor, start = list(K = 20, Vm = 120), 
                  trace = TRUE)
```


```{r}
deviance(L.minor.m1)
```


```{r}
d2 <- sum((L.minor$rate -predict(L.minor.m1))^2)
all.equal(deviance(L.minor.m1), d2)
```


```{r}
logLik(L.minor.m1)
```


```{r}
coef(L.minor.m1)
```


```{r}
summary(L.minor.m1)
```


```{r}
fitted(L.minor.m1)
```


```{r}
concVal <- with(L.minor, seq(min(conc), max(conc), length.out = 10))
concVal
```


```{r}
predict(L.minor.m1, newdata = data.frame(conc = concVal))
```


```{r}
plot(rate ~ conc, 
     data = L.minor,
     ylim = c(10, 130), 
     ylab = "Uptake rate (weight/h)", 
     xlab = Substrate ~ concentration ~ (mmol ~ m^-3)) 
lines(L.minor$conc, fitted(L.minor.m1))
```


```{r}
plot(rate ~ conc, 
     data = L.minor,
     ylim = c(10, 130), 
     ylab = "Uptake rate (weight/h)", 
     xlab = Substrate ~ concentration ~ (mmol ~ m^-3))

concVal <- with(L.minor, seq(min(conc), max(conc), length.out = 100))
lines(concVal, predict(L.minor.m1, newdata = data.frame(conc = concVal)))
abline(h = coef(L.minor.m1)[2], lty = 2)
```


```{r}
L.minor.m1con <- nlsContourRSS(L.minor.m1)
```


```{r}
#par(pty = "s")
plot(L.minor.m1con, col = FALSE, nlev = 10)
```

## 2.3 Generalised linear models

```{r}
## this code should be runned in the clean R session
## library(nlrwr) cause error 
# data(L.minor, package = "nlrwr")
# L.minor.m4 <- glm(rate ~ I(1/conc), 
#                   data = L.minor, 
#                   family = gaussian("inverse"))
# summary(L.minor.m4)
```


## Excercises

2.1

```{r}
y0_start = mean(RGRcurve[RGRcurve$Day == 0, "RGR"])
y1 = mean(RGRcurve[RGRcurve$Day == 1, "RGR"])
b_start = 1 / log(y1/y0_start)


e2.1 <- nls(RGR ~ y0 * exp(Day/b),
            data = RGRcurve,
            start = list(y0 = y0_start, b = b_start))

plot(RGRcurve$Day, RGRcurve$RGR, xlab = "Day", ylab = "RGR")
nd <- with(RGRcurve, seq(min(Day), max(Day), length.out = 101))
lines(nd, predict(e2.1, newdata = data.frame(Day = nd)), col = 2)
```

2.3

```{r}
plotfit(L.minor.m1)
```


# 3 Starting Values and Self-starters

## 3.1 Finding starting values

```{r}
#install.packages("NISTnls")
data(Chwirut2, package = "NISTnls")
plot(y ~ x, 
     data = Chwirut2, 
     xlab = "Metal distance", 
     ylab = "Ultrasonic response")
```


```{r}
expFct <- function(x, beta1, beta2, beta3) {
  exp(-beta1 * x)/(beta2 + beta3 * x)
}

plot(y ~ x, 
     data = Chwirut2, 
     xlab = "Metal distance", 
     ylab = "Ultrasonic response",
     ylim = c(0, 100)
     )
curve(expFct(x, beta1 = 1, beta2 = 0.01, beta3 = 1), add = TRUE, col = 2)
```


```{r}
plot(y ~ x, data = Chwirut2, xlab = "Metal distance",
     ylab = "Ultrasonic response", ylim = c(0, 100))
curve(expFct(x, beta1 = 0.1, beta2 = 0.01, beta3 = 1), add = TRUE, lty = 2,
      col = 2)
curve(expFct(x, beta1 = 0.1, beta2 = 0.01, beta3 = 0.1), add = TRUE, lty = 3,
      col = 3)
curve(expFct(x, beta1 = 0.1, beta2 = 0.01, beta3 = 0.01), add = TRUE, lty = 4,
      col = 4)
curve(expFct(x, beta1 = 0.2, beta2 = 0.01, beta3 = 0.01), add = TRUE, lty = 1,
      col = 6)
```


```{r}
Chwirut2.m1 <- nls(
  y ~ expFct(x, beta1, beta2, beta3),
  data = Chwirut2,
  start = list(beta1 = 0.2, beta2 = 0.01, beta3 = 0.01))
summary(Chwirut2.m1)
```


```{r}
## bad starting
# Chwirut2.m0 <- nls(
#   y ~ expFct(x, beta1, beta2, beta3),
#   data = Chwirut2,
#   start = list(beta1 = 1, beta2 = 0.01, beta3 = 1))
# summary(Chwirut2.m0)

## nlsLM may solve the bad starting
Chwirut2.m0 <- minpack.lm::nlsLM(
  y ~ expFct(x, beta1, beta2, beta3),
  data = Chwirut2,
  start = list(beta1 = 1, beta2 = 0.01, beta3 = 1))
summary(Chwirut2.m0)
```


```{r}
# grid.Chwirut2 <- expand.grid(list(beta1 = seq(0.1, 1, by = 0.1),
#                                   beta2 = c(0.01),
#                                   beta3 = seq(0.1, 1, by = 0.1)))
grid.Chwirut2 <- expand.grid(beta1 = seq(0.1, 1, by = 0.1),
                             beta2 =  0.01,
                             beta3 = seq(0.1, 1, by = 0.1))
grid.Chwirut2
```


```{r}
Chwirut2.m2a <- nls2(
  y ~ expFct(x, beta1, beta2, beta3),
  data = Chwirut2,
  start = grid.Chwirut2,
  algorithm = "brute-force"
)
Chwirut2.m2a
```


```{r}
nls(
  y ~ expFct(x, beta1, beta2, beta3),
  data = Chwirut2,
  start = as.list(coef(Chwirut2.m2a)))  # input as starting value
```

## 3.2 Using self-starter functions

```{r}
L.minor.m2 <- nls(rate ~ SSmicmen(conc, Vm, K), data = L.minor)
summary(L.minor.m2)
```


```{r}
expModel <- function(predictor, b, y0) {
  y0 * exp(predictor/b)
}

expModelInit <- function(mCall, LHS, data) {
  xy <- sortedXyData(mCall[["predictor"]], LHS, data)
  lmFit <- lm(log(xy[, "y"]) ~ xy[, "x"])
  coefs <- coef(lmFit)
  y0 <- exp(coefs[1])
  b <- 1/coefs[2]
  value <- c(b, y0)
  names(value) <- mCall[c("b", "y0")]
  value
}

SSexp2 <- selfStart(expModel, expModelInit, c("b", "y0"))
```


```{r}
with(RGRcurve, SSexp2(Day, 4, 0.2))
```


```{r}
## ERROR
#getInitial(RGR ~ SSexp2(Day, b, y0), data = RGRcurve)
```


# 4 More on nls()

## 4.2 Supplying gradient information

```{r}
MMfct1 <- function(conc, K, Vm) {
  numer <- Vm * conc
  denom <- K + conc
  mean <- numer/denom
  partialK <- -numer/(denom^2)
  partialVm <- mean/Vm
  attr(mean, "gradient") <- cbind(partialK, partialVm)
  return(mean)
}
MMfct1(1, 2, 3)
```


```{r}
L.minor.mgr1 <- nls(rate ~ MMfct1(conc, K, Vm), 
                    data = L.minor, 
                    start = list(K = 1, Vm = 1),
                    trace = TRUE)
summary(L.minor.mgr1)
```


```{r}
## without derivative
nls(rate ~ Vm * conc/(K + conc), 
    data = L.minor, start = list(K = 1, Vm = 1), 
    trace = TRUE)
```


```{r}
MMfct2 <- deriv(~ Vm * conc / (K + conc), c("K", "Vm"), function(conc, K, Vm) {
})
MMfct2
MMfct2(1, 2, 3)
```

## 4.3 Conditionally linear parameters

```{r}
L.minor.m3 <- nls(rate ~ conc/(K + conc), 
                  data = L.minor, 
                  algorithm = "plinear",
                  start = list(K = 20))
summary(L.minor.m3)
```


```{r}
data(segreg)
plot(C ~ Temp, data = segreg, 
     xlab = Mean ~ temperature ~ (degree ~ F),
     ylab = "Energy consumption (kWh)")
```


```{r}
profRSS1 <- function(gamma) {
  deviance(lm(C ~ pmax(0, Temp - gamma), data = segreg))
}
profRSS2 <- Vectorize(profRSS1, "gamma")
```



```{r}
l <- lm( C ~ pmax(0, Temp - 40), data = segreg)
summary(l)
```


```{r}
plot(segreg$Temp, segreg$C)
points(segreg$Temp, predict(l), col = 2)
```


```{r}
plot(profRSS2(Temp) ~ Temp, 
     data = segreg,
     type = "l", 
     xlab = expression(gamma),
     ylab = "Profile RSS")
```


```{r}
plot(profRSS2(Temp) ~ Temp, 
     data = data.frame(Temp = seq(min(segreg$Temp), 
                                  max(segreg$Temp), 
                                  length.out = 101)),
     type = "l", 
     xlab = expression(gamma),
     ylab = "Profile RSS")
```


## 4.4 Fitting models with several predictor variables

```{r}
RScompetition.m1 <- nls(
  biomass ~ a/(1 + b * (x + c * z)),
  data = RScompetition,
  start = list(a = 20, b = 1, c = 1)
)
summary(RScompetition.m1)
```


```{r}
virDensity <- with(RScompetition, x + coef(RScompetition.m1)[3] * z)
virDenVal <- seq(0, max(virDensity), length.out = 100)
biomassVal <- predict(RScompetition.m1, data.frame(x = virDenVal, z = 0))
```


```{r}
plot(biomassVal ~ virDenVal, type = "l", 
     ylab = "Biomass of sensitive biotype (g/plant)",
     xlab = Virtual ~ density ~ (plants/m^2))
with(RScompetition, points(biomass ~ virDensity))
```


```{r}
par(pty = "s")
plot(Q ~ I, data = IQsig)
theta <- 0:360 * (pi/180)
lines(cos(theta), sin(theta))
```

```{r}
IQsig.m1 <- nls(
  ~ ((I - I0)^2 - 2 * gamma * sin(phi) * (I - I0) * (Q - Q0) + 
       gamma * gamma * (Q - Q0)^2) - (rho * gamma * cos(phi))^2, 
  data = IQsig, 
  start = list(I0 = -0.005, gamma = 1, phi = -0.005, Q0 = -0.005, rho = 1))
summary(IQsig.m1)
```


# 5 Model Diagnostics

## 5.2 Checking the mean structure

```{r}
plot(p ~ T, data = vapCO, log = "y",
     xlab = "Temperature (K)",
     ylab = "Pressure (Pa)")
```


```{r}
vapCO.m1 <- nls(
  log(p) ~ A - B/(C + T), 
  data = vapCO,
  start = list(A = 10, B = 100, C = -10))
summary(vapCO.m1)
```


```{r}
plot(p ~ T, data = vapCO, log = "y",
     xlab = "Temperature (K)",
     ylab = "Pressure (Pa)")
lines(vapCO$T, exp(fitted(vapCO.m1)), col = 2)
```


```{r}
plot(weight ~ conc, data = lettuce,
     xlab = "Concentration (mg/l)",
     ylab = "Biomass (g)", log = "x")
```


```{r}
plot(fitted(vapCO.m1), residuals(vapCO.m1),
     xlab = "Fitted Values", ylab = "Residuals")
abline(a = 0, b = 0)
```


```{r}
plot(rootl ~ conc, data = ryegrass,
     xlab = "Concentration (mM)",
     ylab = "Root length (cm)")
```


```{r}
ryegrass.m1 <- lm(rootl ~ as.factor(conc), data = ryegrass)
summary(ryegrass.m1)
```


```{r}
ryegrass.m2 <- nls(
  rootl ~ c + (d - c)/(1 + exp(b * +(log(conc) - log(e)))),
  data = ryegrass,
  start = list(b = 1, c = 0.6, d = 8, e = 3)
)
summary(ryegrass.m2)
```


```{r}
anova(ryegrass.m2, ryegrass.m1)
```


```{r}
Q <- -2 * (logLik(ryegrass.m2) - logLik(ryegrass.m1))
df.Q <- df.residual(ryegrass.m2) - df.residual(ryegrass.m1)
1 - pchisq(Q, df.Q)
```


## 5.3 Variance homogeneity

















# ----